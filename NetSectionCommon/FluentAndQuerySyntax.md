# Fluent and Query syntax LINQ

## Синтаксис запросов и синтаксис методов в LINQ

 Рассматрим три способа создания запросов LINQ на языке C#.

    Cинтаксис запроса

    Cинтаксис метода

    Cочетания синтаксиса запроса и синтаксиса метода

    Краткие выводы

## Cинтаксис запроса

Синтаксис запросов и синтаксис методов семантически идентичны, но многие пользователи найдут синтаксис запросов более простым и более удобным для чтения.

```csharp 
Console.WriteLine(new String('-', 30) + "Query" + new String('-', 30));
// Query #1.
List<int> numbers = new List<int>() { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

IEnumerable<int> filteringQuery = from num in numbers
                                    where num < 3 || num > 7
                                    select num;
foreach (var item in filteringQuery)
{
    Console.WriteLine(item);
}

Console.WriteLine(new String('-', 30) + "Query" + new String('-', 30));

// Query #2.
IEnumerable<int> orderingQuery = from num in numbers
                                    where num < 3 || num > 7
                                    orderby num ascending
                                    select num;
foreach (var item in orderingQuery)
{
    Console.WriteLine(item);
}

Console.WriteLine(new String('-', 30)+"Query" + new String('-', 30));

// Query #3.
string[] groupingQuery = { "carrots", "cabbage", "broccoli", "beans", "barley" };
IEnumerable<IGrouping<char, string>> queryFoodGroups = from item in groupingQuery
                                                        group item by item[0];

foreach (var item in queryFoodGroups)
{
    foreach (var item2 in item)
    {
        Console.WriteLine($"{item2}");
    }
}

Console.ReadKey();
```
Обратите внимание, что тип запросов — IEnumerable<T>. Все эти запросы можно написать с помощью var, как показано в примере ниже.
```csharp 
var query = from num in numbers
            where num < 3 || num > 7
            select num;
```
В каждом из приведенных выше примеров фактическое выполнение запроса откладывается до использования переменной запроса в операторе foreach.

## Синтаксис метода

Некоторые операции запросов должны быть выражены в виде вызова метода.Чаще всего используются методы, возвращающие одноэлементные числовые значения, например Sum,Max,Min,Averageи т.д.Эти методы всегда должны быть вызваны последними в запросе, поскольку они представляют только одно значение и не могут служить источником дополнительных действий запроса.В следующем примере демонстрируется вызов метода в выражении запроса.
```csharp 
List<int> numbers1 = new List<int>() { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
List<int> numbers2 = new List<int>() { 15, 14, 11, 13, 19, 18, 16, 17, 12, 10 };

// Query #4.
double average = numbers1.Average();

// Query #5.
IEnumerable<int> concatenationQuery = numbers1.Concat(numbers2);
```

Если у метода есть параметры, они представлены в виде лямбда-выражения, как показано в следующем примере.
```csharp 
IEnumerable<int> largeNumbersQuery = numbers2.Where(c => c > 15);
```

В предыдущих запросах только запрос №4 выполнялся немедленно. Причина заключается в том, что он возвращает одиночное значение, а не универсальную коллекцию IEnumerable<T>.Сам метод должен использовать foreach для вычисления значения.
Любой их перечисленных ранее запросов можно написать с использованием неявной типизации с помощью var, как показано в следующем примере.
```csharp 
var average = numbers1.Average();

var concatenationQuery = numbers1.Concat(numbers2);

var largeNumbersQuery = numbers2.Where(c => c > 15);
```

## Cочетания синтаксиса запроса и синтаксиса метода

В этом примере демонстрируется использование синтаксиса метода для результатов предложения запроса.Нужно всего лишь заключить выражение запроса в скобки, а затем применить оператор точки и вызвать метод.В следующем примере запрос #7 возвращает количество чисел, значение которых лежит в диапазоне от 3 до 7.Однако в общем случае лучше использовать вторую переменную для хранения результатов вызова метода.Таким образом, будет меньше вероятность перепутать запрос с результатами запроса.
```csharp 
// Query #7.
// Using a query expression with method syntax
int numCount1 = (from num in numbers1
                where num < 3 || num > 7
                select num).Count();

// Better: Create a new variable to store
// the method call result
IEnumerable<int> numbersQuery = from num in numbers1
                                where num < 3 || num > 7
                                select num;
int numCount2 = numbersQuery.Count();
```
Запрос №7 возвращает одиночное значение, а не коллекцию, поэтому он выполняется мгновенно.
Предыдущий запрос можно написать с использованием неявной типизации с помощью var, как показано в следующем примере:
```csharp 
var numCount = (from num in numbers...
```
Можно использовать синтаксис метода следующим образом.
```csharp 
var numCount = numbers.Where(n => n < 3 || n > 7).Count();
```
Можно использовать явную типизацию следующим образом.
```csharp 
int numCount = numbers.Where(n => n < 3 || n > 7).Count();
```

## Краткие выводы

Cинтаксиса запроса и синтаксис метода семантически идентичны, но многие люди находят синтаксис запросов более простым и понятным для чтения. Однако нужно учитывать что, синтаксис запроса должен быть преобразован в вызовы методов для среды CLR .NET, когда код компилируется.

Длинные и сложные запросы в синтаксисе методов могут стать нечитаемыми - особенно при частом использовании анонимных классов. Синтаксис же запроса скрывает эти анонимные классы
```csharp 
var q1 = trees.SelectMany(t => t.Leaves.Select(l => new { tree = t, leaf = l }))
                .OrderBy(x => x.leaf.color)
                .Select(x => x.tree.name);
```
Попробуйте переписать запрос выше без анонимного класса. А ведь в более длинных запросах могут появиться уже либо вложенные анонимные классы - либо постоянные копирования из одного анонимного класса в другой.

При использовании синтаксиса запроса многие анонимные классы успешно прячутся
```csharp 
var q1 = from tree in trees
         from leaf in tree.Leaves
         order by leaf.Color
         select tree.Name;
```
Также в длинных запросах при использовании методов может быстро надоесть писать один и тот же префикс для каждого замыкания - в синтаксисе запроса же range variable определяется только 1 раз.

По этой причине в сложных запросах синтаксис запроса, как правило, предпочтительнее.

С другой стороны, некоторые вещи сделать в синтаксисе запроса просто невозможно.
К примеру, перегрузки методов, принимающие IEqualityComparer, могут быть вызваны только как методы.
Также синтаксис методов позволяет "накапливать" сложный запрос в переменной в зависимости от внешних условий - что полезно при обработке блоков фильтрации.
```csharp 
if (filters.Foo.HasValue) 
  q = q.Where(x => x.Foo == filters.Foo);

if (filters.Bar != null) 
  q = q.Where(x => x.Bar.Name == filters.Bar);
```
Помните, что некоторые запросы должны быть выражены как вызовы методов. Например, вы должны использовать вызов метода для выражения запроса, который извлекает количество элементов, которые соответствуют указанному условию. Вы также должны использовать вызов метода для запроса, который извлекает элемент с максимальным значением в исходной последовательности. Таким образом, это может быть преимуществом использования синтаксиса метода, чтобы сделать код более согласованным. Однако, конечно, вы всегда можете применить метод после синтаксиса запроса: 
```csharp 
int maxNum = (from num in numbers
                where num % 2 == 0
                select num).Max();
```