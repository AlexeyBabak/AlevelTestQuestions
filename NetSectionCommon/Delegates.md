# How does delegate work?
## Как работают делегаты

### Полезные ссылки

[Делегаты и события в .NET](https://habr.com/ru/post/198694/)

### Типы делегатов

В каком-то смысле вы можете думать о типе делегата как о некоем интерфейсе, в котором определён лишь один метод с чётко заданной сигнатурой (в этой статье под сигнатурой метода я буду понимать все его входные и выходные (ref и out) параметры, а также возвращаемое значение). Тогда экземпляр делегата — это объект, реализующий этот интерфейс. В этом понимании, имея экземпляр делегата, вы можете вызвать любой существующий метод, сигнатура которого будет совпадать с сигнатурой метода, определённого в «интерфейсе». Делегаты обладают и другой функциональностью, но возможность делать вызовы методов с заранее определёнными сигнатурами — это и есть самая суть делегатов. Экземпляр делегата хранит ссылку (указатель, метку) на целевой метод и, если этот метод является экземплярным, то и ссылку на экземпляр объекта (класса или структуры), в котором «находится» целевой метод.

Тип делегата объявляется при помощи ключевого слова delegate. Типы делегатов могут существовать как самостоятельные сущности, так и быть объявленными внутри классов или структур. Например:

```csharp 
namespace DelegateArticle
 {
     public delegate string FirstDelegate (int x);
     
     public class Sample
     {
         public delegate void SecondDelegate (char a, char b);
     }
 }
```

В этом примере объявлены два типа делегата. Первый — DelegateArticle.FirstDelegate, который объявлен на уровне пространства имён. Он «совместим» с любым методом, который имеет один параметр типа int и возвращает значение типа string. Второй — DelegateArticle.Sample.SecondDelegate, который объявлен уже внутри класса и является его членом. Он «совместим» с любым методом, который имеет два параметра типа char и не возвращает ничего, так как возвращаемый тип помечен как void.

Обратите внимание, что оба типа делегата имеют модификатор доступа public. Вообще, по отношению модификаторов доступа типы делегатов ведут себя так же, как классы и структуры. Если для типа делегата явно не указан модификатор доступа и этот тип объявлен внутри пространства имён, то он будет доступен для всех объектов, также находящихся внутри этого пространства имён. Если же тип делегата без модификатора объявлен внутри класса или структуры, то он будет закрытым, аналогично действию модификатора private.

При объявлении типа делегата нельзя использовать модификатор static.

Но помните, что ключевое слово delegate не всегда означает объявление типа делегата. Это же ключевое слово используется при создании экземпляров делегатов при использовании анонимных методов.

Оба типа делегата, объявленные в этом примере, наследуются от System.MulticastDelegate, который, в свою очередь, наследуется от System.Delegate. На практике учитывайте наследование только от MulticastDelegate — различие между Delegate и MulticastDelegate лежит прежде всего в историческом аспекте. Эти различия были существенны в бета-версиях .NET 1.0, но это было неудобно, и Microsoft решила объединить два типа в один. К сожалению, решение было сделано слишком поздно, и когда оно было сделано, делать такое серьёзное изменение, затрагивающее основу .NET, не решились. Поэтому считайте, что Delegate и MulticastDelegate — это одно и то же.

Каждый тип делегата, созданный вами, наследует члены от MulticastDelegate, а именно: один конструктор с параметрами Object и IntPtr, а также три метода: Invoke, BeginInvoke и EndInvoke. К конструктору мы вернёмся чуточку позже. Вообще-то эти три метода не наследуются в прямом смысле, так как их сигнатура для каждого типа делегата своя — она «подстраивается» под сигнатуру метода в объявленном типе делегата. Глядя на пример кода выше, выведем «наследуемые» методы для первого типа делегата FirstDelegate:

```csharp 
public string Invoke (int x);
public System.IAsyncResult BeginInvoke(int x, System.AsyncCallback callback, object state);
public string EndInvoke(IAsyncResult result);
```

Как вы видите, возвращаемый тип методов Invoke и EndInvoke совпадает с таковым, указанным в сигнатуре делегата, так же, как и параметр метода Invoke и первый параметр BeginInvoke.

### Создание экземпляров делегатов

Прежде всего замечу, что эта статья не рассказывает о новых функциональных возможностях C# 2.0 и 3.0, связанных с созданием экземпляров делегатов, так же, как и не покрывает обобщённые делегаты, появившиеся в C# 4.0. Моя отдельная статья о замыканиях «The Beauty of Closures» повествует о новых возможностях делегатов, которые появились в C# 2.0 и 3.0; кроме того, много информации по этой теме содержится в главах 5, 9 и 13 моей книги «C# in Depth». Я буду придерживаться явного стиля создания экземпляров делегатов, который появился в C# 1.0/1.1, так как полагаю, что такой стиль проще для понимания того, что происходит «под капотом». Вот когда вы постигнете основы, то можно будет приступать к освоению новых возможностей из C# 2.0, 3.0 и 4.0; и наоборот, без твёрдого понимания основ, изложенных в этой статье, «новый» функционал делегатов может быть для вас неподъёмным.

Как говорилось ранее, каждый экземпляр делегата обязательно содержит ссылку на целевой метод, который может быть вызван через этот экземпляр делегата, и ссылку на экземпляр объекта (класса или структуры), в котором объявлен целевой метод. Если целевой метод является статическим, то, естественно, ссылка на экземпляр отсутствует. CLR поддерживает и другие, немного различные формы делегатов, где первый аргумент, передаваемый в статический метод, хранится в экземпляре делегата, или же ссылка на целевой экземплярный метод передаётся как аргумент при вызове метода. Более подробно об этом можно прочитать в документации к System.Delegate на MSDN, однако сейчас, на данном этапе, эти дополнительные сведения не существенны.

Итак, мы знаем, что для создания экземпляра нам нужны две «единицы» данных (ну и сам тип делегата, конечно), однако как дать знать об этом компилятору? Мы используем то, что в спецификации к C# называется «выражение создания делегата» (delegate-creation-expression), что является одной из форм new delegate-type (expression). Выражение (expression) должно быть или другим делегатом с таким же самым типом (или с совместимым типом делегата в C# 2.0), или же «группой методов» (method group), которая состоит из названия метода и опциональной ссылки на экземпляр объекта. Группа методов указывается точно также, как и обычный вызов метода, но без каких-либо аргументов и круглых скобок. Необходимость в создании копий делегата возникает довольно редко, поэтому мы сосредоточимся на более общих формах. Примеры ниже.


```csharp 
/* Два выражения создания экземпляров делегатов d1 и d2 эквивалентны. Здесь InstanceMethod является экземплярным методом, который объявлен в классе, в котором также объявлены нижеприведённые выражения (базовый класс). Соответственно, ссылка на экземпляр объекта — this, и именно поэтому эти выражения эквивалентны. */
FirstDelegate d1 = new FirstDelegate(InstanceMethod);
 FirstDelegate d2 = new FirstDelegate(this.InstanceMethod);

/* Здесь (d3) мы создаём экземпляр делегата, ссылающийся на тот же метод, что и в предыдущих двух выражениях, но на этот раз с другим экземпляром класса. */
FirstDelegate d3 = new FirstDelegate(anotherInstance.InstanceMethod);

/* В этом (d4) экземпляре делегата используется уже другой метод, тоже экземплярный, который объявлен в другом классе; мы указываем экземпляр этого класса и сам метод. */
FirstDelegate d4 = new FirstDelegate(instanceOfOtherClass.OtherInstanceMethod);

/* А вот этот (d5) экземпляр делегата использует статический метод, который расположен в том же классе, где и это выражение (базовом классе). */
FirstDelegate d5 = new FirstDelegate(StaticMethod);

/* Здесь (d6) экземпляр делегата использует другой статический метод, объявленный на этот раз в стороннем классе. */
FirstDelegate d6 = new FirstDelegate(OtherClass.OtherStaticMethod);
```

Конструктор делегата, о котором мы говорили ранее, имеет два параметра — ссылку на вызываемый метод типа System.IntPtr (в документации MSDN этот параметр называется method) и ссылку на экземпляр объекта типа System.Object (в документации MSDN этот параметр называется target), которая принимает значение null, если метод, указанный в параметре method, является статическим.

Необходимо сделать важное замечание: экземпляры делегатов могут ссылаться на методы и экземпляры объектов, которые будут невидимыми (вне области видимости) по отношению к тому месту в коде, где будет произведён вызов экземпляра делегата. Например, при создании экземпляра делегата может быть использован приватный (private) метод, а потом этот экземпляр делегата может быть возвращён из другого, публичного (public) метода или свойства. С другой стороны, экземпляр объекта, указанный при создании экземпляра делегата, может быть объектом, который при вызове будет неизвестным по отношению к тому объекту, в котором был совершен вызов. Важно то, что и метод, и экземпляр объекта должны быть доступны (находиться в области видимости) на момент создания экземпляра делегата. Другими словами, если (и только если) в коде вы можете создать экземпляр определённого объекта и вызвать определённый метод из этого экземпляра, то вы можете использовать этот метод и экземпляр объекта для создания экземпляра делегата. А вот во время вызова ранее созданного экземпляра делегата права доступа и область видимости игнорируются. Кстати, о вызовах…

### Вызов экземпляров делегатов

Экземпляры делегатов вызываются таким же образом, как вызываются обычные методы. К примеру, вызов экземпляра делегата d1, тип которого определён в самом верху как delegate string FirstDelegate (int x), будет следующим:

```csharp 
string result = d1(10);
```

Метод, ссылку на который хранит экземпляр делегата, вызывается «в рамках» (или «в контексте», если другими словами) экземпляра объекта, если такой есть, после чего возвращается результат. Написание полноценной программы, демонстрирующей работу делегатов, и при этом компактной, не содержащей «лишнего» кода, является непростой задачей. Тем не менее, ниже приведена подобная программа, содержащая один статический и один экземплярный метод. Вызов DelegateTest.StaticMethod эквивалентен вызову StaticMethod — я включил название класса, чтобы сделать пример более понимаемым.


```csharp 
using System;

public delegate string FirstDelegate (int x);
     
class DelegateTest
 {    
     string name;
     
     static void Main()
     {
         FirstDelegate d1 = new FirstDelegate(DelegateTest.StaticMethod);
         
         DelegateTest instance = new DelegateTest();
         instance.name = "My instance";
         FirstDelegate d2 = new FirstDelegate(instance.InstanceMethod);
         
         Console.WriteLine (d1(10)); // Выводит на консоль "Static method: 10"
         Console.WriteLine (d2(5));  // Выводит на консоль "My instance: 5"
     }
     
     static string StaticMethod (int i)
     {
         return string.Format ("Static method: {0}", i);
     }

     string InstanceMethod (int i)
     {
         return string.Format ("{0}: {1}", name, i);
     }
 }
```

Синтаксис C# по вызову экземпляров делегатов является синтаксическим сахаром, маскирующим вызов метода Invoke, который есть у каждого типа делегата. Делегаты могут выполняться асинхронно, если предоставляют методы BeginInvoke/EndInvoke, но об этом позже.

### Комбинирование делегатов

Делегаты могут комбинироваться (объединяться и вычитаться) таким образом, что когда вы вызываете один экземпляр делегата, то вызывается целый набор методов, причём эти методы могут быть из различных экземпляров различных классов. Когда я раньше говорил, что экземпляр делегата хранит ссылки на метод и на экземпляр объекта, я немного упрощал. Это справедливо для тех экземпляров делегатов, которые представляют один метод. Для ясности в дальнейшем я буду называть такие экземпляры делегатов «простыми делегатами» (simple delegate). В противовес им, существуют экземпляры делегатов, которые фактически являются списками простых делегатов, все из которых основываются на одном типе делегата (т.е. имеют одинаковую сигнатуру методов, на которые ссылаются). Такие экземпляры делегатов я буду называть «комбинированными делегатами» (combined delegate). Несколько комбинированных делегатов могут быть скомбинированы между собой, фактически становясь одним большим списком простых делегатов. Список простых делегатов в комбинированном делегате называется «списком вызовов» или «списком действий» (invocation list). Т.о., список вызовов — это список пар ссылок на методы и экземпляры объектов, которые (пары) расположены в порядке вызова.

Важно знать, что экземпляры делегатов всегда неизменяемы (immutable). Каждый раз при объединении экземпляров делегатов (а также при вычитании – это мы рассмотрим чуть ниже) создаётся новый комбинированный делегат. В точности, как и со строками: если вы применяете String.PadLeft к экземпляру строки, то метод не изменяет этот экземпляр, а возвращает новый экземпляр с проделанными изменениями.

Объединение (также встречается термин «сложение») двух экземпляров делегатов обычно производится при помощи оператора сложения, как если бы экземпляры делегатов были числами или строками. Аналогично, вычитание (также встречается термин «удаление») одного экземпляра делегата из другого производится при помощи оператора вычитания. Имейте ввиду, что при вычитании одного комбинированного делегата из другого вычитание производится в рамках списка вызовов. Если в оригинальном (уменьшаемом) списке вызовов нет не одного из тех простых делегатов, которые находятся в вычитаемом списке вызовов, то результатом операции (разностью) будет оригинальный список. В противном случае, если в оригинальном списке присутствуют простые делегаты, присутствующие и в вычитаемом, то в результирующем списке будут отсутствовать лишь последние вхождения простых делегатов. Впрочем, это легче показать на примерах, нежели описать на словах. Но вместо очередного исходного кода я продемонстрирую работу объединения и вычитания на примере нижеследующей таблицы. В ней литералами d1, d2, d3 обозначены простые делегаты. Далее, обозначение [d1, d2, d3] подразумевает комбинированный делегат, который состоит из трёх простых именно в таком порядке, т.е. при вызове сначала будет вызван d1, потом d2, а затем d3. Пустой список вызовов представлен значением null.

```csharp 
Выражение 	                            Результат
null + d1 	                            d1
d1 + null 	                            d1
d1 + d2 	                            [d1, d2]
d1 + [d2, d3] 	                        [d1, d2, d3]
[d1, d2] + [d2, d3] 	                [d1, d2, d2, d3]
[d1, d2] — d1 	                        d2
[d1, d2] — d2 	                        d1
[d1, d2, d1] — d1                       [d1, d2]
[d1, d2, d3] — [d1, d2] 	            d3
[d1, d2, d3] — [d2, d1] 	            [d1, d2, d3]
[d1, d2, d3, d1, d2] — [d1, d2] 	    [d1, d2, d3]
[d1, d2] — [d1, d2] 	                null
```

Кроме оператора сложения, экземпляры делегатов могут объединяться при помощи статического метода Delegate.Combine; аналогично ему, операция вычитания имеет альтернативу в виде статического метода Delegate.Remove. Вообще говоря, операторы сложения и вычитания — это своеобразный синтаксический сахар, и компилятор C#, встречая их в коде, заменяет на вызовы методов Combine и Remove. И именно потому, что данные методы являются статическими, они легко справляются с null-экземплярами делегатов.

Операторы сложения и вычитания всегда работают как часть операции присваивания d1 += d2, которая полностью эквивалента выражению d1 = d1+d2; то же самое для вычитания. Снова-таки, напоминаю, что экземпляры делегатов, участвующие в сложении и вычитании, не изменяются в процессе операции; в данном примере переменная d1 просто сменит ссылку на новосозданный комбинированный делегат, состоящий из «старого» d1 и d2.

Обратите внимание, что добавление и удаление делегатов происходит с конца списка, поэтому последовательность вызовов x += y; x -= y; эквивалентна пустой операции (переменная x будет содержать неизменный список подписчиков, прим. перев.).

Если сигнатура типа делегата объявлена такой, что возвращает значение (т.е. возвращаемое значение не является void) и «на основе» этого типа создан комбинированный экземпляр делегата, то при его вызове в переменную будет записано возвращаемое значение, «предоставленное» последним простым делегатом в списке вызовов комбинированного делегата.

Если есть комбинированный делегат (содержащий список вызовов, состоящий из множества простых делегатов), и при его вызове в каком-то простом делегате произойдёт исключение, то в этом месте вызов комбинированного делегата прекратится, исключение будет проброшено, и все остальные простые делегаты из списка вызовов так никогда и не будут вызваны.