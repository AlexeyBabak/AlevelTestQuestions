# Collections
## Коллекции

5 основных типов коллекций:
- List
- Dictionary
- HashSet
- Stack
- Queue

### List<T>

Представляет список объектов, к которым можно получить доступ по индексу. <T> здесь означает, что это общий список (используется дженерик).
В отличие от массивов фиксированного размера, списки могут увеличиваться в размерах динамически. Вот почему их также называют динамическими массивами или векторами. Внутренне, список использует массив для хранения. Если он заполнится, он создаст новый массив большего размера и скопирует элементы из существующего массива в новый.
Зачастую используюeтся List вместо Array, даже если вы работаете с фиксированным набором элементов.

Примеры операций со списками:

```csharp 
// Creating a list
List<int> list = new List<int>();

// Creating a list with an initial size
var list = new List<int>(100);

// Add an item at the end of the list
list.Add(4);
 
// Add an item at index 0
list.Insert(4, 0);
 
// Remove an item from list
list.Remove(1);
 
// Remove the item at index 0
list.RemoveAt(0);
 
// Return the item at index 0
var first = list[0];
 
// Return the index of an item
var index = list.IndexOf(4);
 
// Check to see if the list contains an item
var contains = list.Contains(4);
 
// Return the number of items in the list 
var count = list.Count;
 
// Iterate over all objects in a list
foreach (var item in list)
{
    Console.WriteLine(item);
}
```

Разберемся где список работает хорошо, а где нет.

**Добавление / удаление элементов в начале или в середине**
Если вы добавляете / удаляете элемент в начале или середине списка, он должен сместить один или несколько элементов во внутреннем массиве. В худшем случае, если вы добавляете / удаляете элемент в самом начале списка, необходимо сместить все существующие элементы. Чем больше список, тем дороже будет эта операция. Мы определяем стоимость этой операции, используя обозначение Big O: O (n), что просто означает, что стоимость линейно возрастает прямо пропорционально размеру ввода. Таким образом, с ростом n время выполнения алгоритма увеличивается прямо пропорционально n.

**Добавление / удаление элементов в конце**
Добавление / удаление элемента в конце списка - это относительно быстрая операция, которая не зависит от размера списка. Существующие элементы не будут сдвинуты. Вот почему стоимость этой операции является относительно постоянной и не зависит от количества элементов в списке. Мы представляем стоимость выполнения этой операции с помощью обозначения Big O: O (1). Итак, 1 здесь означает постоянный.

**Поиск элемента**
При использовании методов, которые включают в себя поиск элемента (например, IndexOf, Contains и Find), List выполняет линейный поиск. Это означает, что он перебирает все элементы своего внутреннего массива и, если находит совпадение, возвращает его. В худшем случае, если этот элемент находится в конце списка, все элементы в списке необходимо отсканировать, прежде чем найти совпадение. Опять же, это еще один пример O (n), где стоимость поиска совпадения линейна и прямо пропорциональна количеству элементов в списке.

**Доступ к элементу по индексу**
В этом списоки хороши. Вы можете использовать индекс для получения элемента в списке, и независимо от того, насколько велик список, стоимость доступа к элементу по индексу остается относительно постоянной, следовательно, O (1).

**Вывод**
Таким образом, добавление / удаление элементов в конце списка и доступ к элементам по индексу - быстрые и эффективные операции с O (1). Поиск элемента в списке включает в себя линейный поиск и в худшем случае O (n). Если вам нужно искать элементы по некоторым критериям, а не по индексу (например, клиент с идентификатором 1234), лучше использовать Dictionary.

### Dictionary<TKey, TValue>

Dictionary - это тип коллекции, который полезен, когда вам нужен быстрый поиск по ключам. Например, представьте, что у вас есть список клиентов, и в рамках задачи вам нужно быстро найти клиента по его идентификатору (или другому уникальному идентификатору, который мы называем ключом). Со списком поиск клиента включает в себя линейный поиск, и стоимость этой операции, как вы узнали ранее, составляет O (n) в худшем случае. Однако при использовании словаря поиск выполняется очень быстро с помощью O (1), что означает, что независимо от того, насколько велик словарь, время поиска остается относительно постоянным.

При хранении или извлечении объекта в словаре вам необходимо указать ключ. Ключ - это значение, которое однозначно идентифицирует объект и не может быть нулевым. Например, чтобы сохранить Customer в словаре, вы можете использовать CustomerID в качестве ключа.

Вот полезные методы, доступные в классе Dictionary:

```csharp
//To create a dictionary, first you need to specify the type of keys and values
var dictionary = new Dictionary<int, Customer>();

//add element in this dictionary 
dictionary.Add(customer.Id, customer);

//add objects to a dictionary during initialization
var dictionary = new Dictionary<int, Customer>
{
     { customer1.Id, customer1 },
     { customer2.Id, customer2 }
}

// Return the customer with ID 1234 
var customer = dictionary[1234];

// Removing an object by its key
dictionary.Remove(1);

// Removing all objects
dictionary.Clear();

var count = dictionary.Count; 
 
var containsKey = dictionary.ContainsKey(1);
 
var containsValue = dictionary.ContainsValue(customer1);
 
// Iterate over keys 
foreach (var key in dictionary.Keys)
{
     Console.WriteLine(dictionary[key]);
}
 
// Iterate over values
foreach (var value in dictionary.Values)
{
     Console.WriteLine(value);
}
 
// Iterate over dictionary
foreach (var keyValuePair in dictionary)
{
     Console.WriteLine(keyValuePair.Key);
     Console.WriteLine(keyValuePair.Value);
}
```

Итак, почему поиск словаря так быстр? Словарь хранит объекты в массиве, но в отличие от списка, в котором объекты добавляются в конец массива (или по указанному индексу), индекс вычисляется с использованием хеш-функции. Поэтому, когда мы сохраняем объект в словаре, он вызывает метод GetHashCode для ключа объекта для вычисления хеша. Затем хэш корректируется до размера массива, чтобы вычислить индекс в массиве для хранения объекта. Позже, когда мы ищем объект по его ключу, метод GetHashCode снова используется для вычисления хеша и индекса. Как вы узнали ранее, поиск объекта по индексу в массиве - это быстрая операция с O (1). Таким образом, в отличие от списков, поиск объекта в словаре не требует сканирования каждого объекта, и независимо от того, насколько велик словарь, он останется чрезвычайно быстрым.

Итак, на следующем рисунке, когда мы сохраняем этот объект в словаре, вызывается метод GetHashCode для ключа. Предположим, он возвращает 1234. Это значение хеш-функции затем корректируется в зависимости от размера внутреннего массива. На этом рисунке длина внутреннего массива равна 6. Таким образом, остаток от деления 1234 на 6 используется для вычисления индекса (в данном случае 4). Позже, когда нам нужно будет найти этот объект, его ключ снова используется для вычисления индекса.

![dictionary](images/Collections_01.png)

Это было упрощенное объяснение того, как работает хеширование. Подсчете хэшей работает сложнее, но вам на самом деле не нужно знать точные детали на этом этапе (кроме как для личных интересов). Все, что вам нужно знать как разработчику C #, - это то, что словари представляют собой коллекции на основе хешей, и поэтому поиск выполняется очень быстро.

### HashSet<T>

HashSet представляет набор уникальных элементов, как математический набор (например, {1, 2, 3}). Набор не может содержать дубликаты, а порядок элементов не имеет значения. Итак, оба {1, 2, 3} и {3, 2, 1} равны.

Используйте HashSet, когда вам нужен супербыстрый поиск уникального списка элементов. Например, вы можете обрабатывать список заказов, и для каждого заказа вам нужно быстро проверить код поставщика из списка действительных кодов поставщиков.

HashSet, похожий на Dictionary, представляет собой коллекцию на основе хеша, поэтому поиск выполняется очень быстро с помощью O (1). Но в отличие от словаря, он не хранит пары ключ / значение; он только хранит значения. Таким образом, каждый объект должен быть уникальным, и это определяется значением, возвращаемым методом GetHashCode. 

Итак, если вы собираетесь хранить пользовательские типы в наборе, вам необходимо переопределить методы GetHashCode и Equals в вашем типе.

Чтобы создать HashSet:

```csharp 
var hashSet = new HashSet<int>();
```

Вы можете добавлять / удалять объекты в HashSet, аналогично списку:

```csharp 
// Initialize the set using object initialization syntax 
var hashSet = new HashSet<int>() { 1, 2, 3 };
 
// Add an object to the set
hashSet.Add(4);
 
// Remove an object 
hashSet.Remove(3);
 
// Remove all objects 
hashSet.Clear();
 
// Check to see if the set contains an object 
var contains = hashSet.Contains(1);
 
// Return the number of objects in the set 
var count = hashSet.Count;
```

HashSet предоставляет множество математических операций над множествами:

```csharp 
// Modify the set to include only the objects present in the set and the other set
hashSet.IntersectWith(another);
 
// Remove all objects in "another" set from "hashSet" 
hashSet.ExceptWith(another);
 
// Modify the set to include all objects included in itself, in "another" set, or both
hashSet.UnionWith(another);
 
var isSupersetOf = hashSet.IsSupersetOf(another);
var isSubsetOf = hashSet.IsSubsetOf(another);
var equals = hashSet.SetEquals(another);
```

### Stack<T>

Стек - это тип коллекции с поведением «последним пришел - первым ушел» (LIFO). Мы часто используем стеки в сценариях, где нам нужно предоставить пользователю способ вернуться назад. Подумайте о своем браузере. Когда вы переходите на разные веб-сайты, эти адреса, которые вы посещаете, помещаются в стек. Затем, когда вы нажимаете кнопку «Назад», элемент в стеке (который представляет текущий адрес в браузере) извлекается, и теперь мы можем получить последний адрес, который вы посетили, из элемента в стеке. Функция отмены в приложениях также реализована с использованием стека.

Вот как вы можете использовать стек в C #:

```csharp 
var stack = new Stack<string>();
             
// Push items in a stack
stack.Push("http://www.google.com");
 
// Check to see if the stack contains a given item 
var contains = stack.Contains("http://www.google.com");
 
// Remove and return the item on the top of the stack
var top = stack.Pop();
 
// Return the item on the top of the stack without removing it 
var top = stack.Peek();
 
// Get the number of items in stack 
var count = stack.Count;
 
// Remove all items from stack 
stack.Clear();
```

Внутренне стек реализован с использованием массива. Поскольку массивы в C # имеют фиксированный размер, когда вы помещаете элементы в стек, может потребоваться увеличить его емкость путем перераспределения большего массива и копирования существующих элементов в новый массив. Если перераспределение не требуется, операция push является O (1); в противном случае, если требуется перераспределение, при условии, что в стеке есть n элементов, все эти элементы необходимо скопировать в новый массив. Это приводит к сложности выполнения O (n).

Pop - это операция O (1).

Contains - Содержит линейную операцию поиска с O (n).

### Queue<T>

Очередь представляет коллекцию с поведением «первым пришел - первым ушел» (FIFO). Мы используем очереди в ситуациях, когда нам нужно обрабатывать элементы по мере их поступления.

Три основные операции с очередью включают в себя:

- Enqueue: добавление элемента в конец очереди
- Dequeue: удаление элемента из начала очереди
- Peek: получить первый элемент, не удаляя его из очереди

Вот как вы можете использовать очередь:

```csharp 
ar queue = new Queue<string>();
 
// Add an item to the queue
queue.Enqueue("transaction1");
 
// Check to see if the queue contains a given item 
var contains = queue.Contains("transaction1");
 
// Remove and return the item on the front of the queue
var front = queue.Dequeue();
 
// Return the item on the front without removing it 
var top = queue.Peek();
             
// Remove all items from queue 
queue.Clear();
 
// Get the number of items in the queue
var count = queue.Count;
```

### Подитожим

List<T> - Списки бывают быстрыми, когда вам нужен доступ к элементу по индексу, но поиск элемента в списке идет медленно, так как требует линейного поиска.

Dictionary<TKey, TValue> - Словари обеспечивают быстрый поиск по ключу. Ключи должны быть уникальными и не могут быть нулевыми.

HashSet<T> - HashSets полезны, когда вам нужен быстрый поиск, чтобы увидеть, существует ли элемент в наборе или нет.

Stack<T> - Стеки обеспечивают поведение LIFO (Last-In-First-Out) и полезны, когда вам нужно предоставить пользователю способ вернуться назад.

Queue<T> - Очереди обеспечивают поведение FIFO (First-In-First-Out) и полезны для последовательной обработки элементов.